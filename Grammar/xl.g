// -------------------------
// --- X-Language Parser ---
// -------------------------

header {
	using System.Collections;
	using antlr;
	
	using Module = XL.Declaration.Module;
	using Schema = XL.Declaration.Schema;
	using Value = XL.Declaration.Value;
	using Pattern = XL.Declaration.Pattern;
	using Process = XL.Declaration.Process;
	using Action = XL.Declaration.Action;
}

//
// NOTE: run 'antlr.Tool' on 'xl-lex.g' first
//
options {
	mangleLiteralPrefix = "TK_";
	language = "CSharp";
	namespace = "XL.Parser";
}

class XLParser extends Parser;
options {
	k=1;
	// use vocabulary generated by lexer
	importVocab=XL;
}

// ------------
// --- Main ---
// ------------
main returns [Module result = new Module()]
	{ Process.Base p; }
	:	( ( KW_PROCESS name ) => process_definition | p=process { result.Processes.Add(p); } | schema_definition )+ EOF
	;

process_definition returns [Process.Base result = null]
	// TODO
	:	KW_PROCESS name LPAREN pattern RPAREN result=process_statement
	;

process returns [Process.Base result = null]
	:	KW_PROCESS result=process_statement
	;

schema_definition
	// TODO
	:	KW_SCHEMA name ASSIGN schema SEMI
	;

// ------------
// --- Misc ---
// ------------
name returns [string result = null]
	:	n:ID { result = n.getText(); }
	;

tag returns [string result = null]
	:	t:ID { result = t.getText(); }
	;


// --------------
// --- Values ---
// --------------
value returns [Value.Base result = null]
	:	result=value_unordered
	|	{ result = Value.Void.Instance; }
	;

value_unordered returns [Value.Base result = null]
	{ ArrayList l = new ArrayList(); Value.Base i; }
	:	i=value_ordered { l.Add(i); } ( PAR i=value_ordered { l.Add(i); } )*
		{ result = (l.Count == 1) ? (Value.Base)l[0] : new Value.Unordered((Value.Base[])l.ToArray(typeof(Value.Base))); }
	;

value_ordered returns [Value.Base result = null]
	{ ArrayList l = new ArrayList(); Value.Base i; }
	:	i=value_simple { l.Add(i); } ( COMMA i=value_simple { l.Add(i); } )*
		{ result = (l.Count == 1) ? (Value.Base)l[0] : new Value.Ordered((Value.Base[])l.ToArray(typeof(Value.Base))); }
	;
	
value_simple returns [Value.Base result = null]
	:	result=value_literal
	|	( tag LSQUARE ) => result=value_element
	|	result=value_new
	|	result=value_variable
	;

value_new returns [Value.Base result = null]
	{ Schema.Base s; }
	:	KW_NEW s=schema_name { result = new Value.New(s); }
	;

value_element returns [Value.Base result = null]
	{ string t; Value.Base v; }
	:	t=tag LSQUARE v=value RSQUARE { result = new Value.Element(t, v); }
	;

value_variable returns [Value.Base result = null]
	{ string n; }
	:	n=name { result = new Value.Variable(n); }
	;

value_literal returns [Value.Base result = null]
	:	result=value_boolean
	|	( INT DOT ) => result=value_floating_point
	|	result=value_integer
	|	result=value_character
	|	result=value_string
	;

value_boolean returns [Value.Base result = null]
	:	KW_TRUE { result = new Value.Boolean(true); }
	|	KW_FALSE { result = new Value.Boolean(false); }
	;

value_integer returns [Value.Base result = null]
	:	i:INT { result = new Value.Integer(Int32.Parse(i.getText())); }
	;

value_floating_point returns [Value.Base result = null]
	// TODO
	:	INT DOT ( INT )?
	;

value_character returns [Value.Base result = null]
	// TODO
	:	CHAR_LITERAL
	;

value_string returns [Value.Base result = null]
	:	s:STRING_LITERAL { result = new Value.String(XL.Declaration.Util.UnquoteString(s.getText())); }
	;


// ----------------
// --- Patterns ---
// ----------------
pattern returns [Pattern.Base result = null]
	:	result=pattern_unordered
	;

pattern_unordered returns [Pattern.Base result = null]
	{ ArrayList l = new ArrayList(); Pattern.Base i; }
	:	i=pattern_ordered { l.Add(i); } ( PAR i=pattern_ordered { l.Add(i); } )*
		{ result = (l.Count == 1) ? (Pattern.Base)l[0] : new Pattern.Unordered((Pattern.Base[])l.ToArray(typeof(Pattern.Base))); }
	;

pattern_ordered returns [Pattern.Base result = null]
	{ ArrayList l = new ArrayList(); Pattern.Base i; }
	:	i=pattern_simple { l.Add(i); } ( COMMA i=pattern_simple { l.Add(i); } )*
		{ result = (l.Count == 1) ? (Pattern.Base)l[0] : new Pattern.Ordered((Pattern.Base[])l.ToArray(typeof(Pattern.Base))); }
	;

pattern_simple returns [Pattern.Base result = null]
	:	result=pattern_void
	|	( tag LSQUARE ) => result=pattern_element
	|	( schema_name FLAT ) => result=pattern_discard
	|	( schema_name name ) => result=pattern_variable
	|	LPAREN result=pattern RPAREN
	;

pattern_element returns [Pattern.Base result = null]
	{ string t; Pattern.Base p; }
	:	t=tag LSQUARE p=pattern RSQUARE { result = new Pattern.Element(t, p); }
	;

pattern_discard returns [Pattern.Base result = null]
	{ Schema.Base s; }
	:	s=schema_name FLAT { result = new Pattern.Discard(s); }
	;

pattern_void returns [Pattern.Base result = null]
	:	KW_VOID { result = Pattern.Void.Instance; }
	;

pattern_variable returns [Pattern.Base result = null]
	{ Schema.Base s; string n; }
	:	s=schema_name n=name { result = new Pattern.Variable(s, n); }
	;


// ---------------
// --- Schemas ---
// ---------------
schema returns [Schema.Base result = null]
	: result=schema_unordered
	;

schema_unordered returns [Schema.Base result = null]
	{ ArrayList l = new ArrayList(); Schema.Base i; }
	:	i=schema_choice { l.Add(i); } ( PAR i=schema_choice { l.Add(i); } )*
		{ result = (l.Count == 1) ? (Schema.Base)l[0] : new Schema.Unordered((Schema.Base[])l.ToArray(typeof(Schema.Base))); }
	;

schema_choice returns [Schema.Base result = null]
	{ ArrayList l = new ArrayList(); Schema.Base i; }
	:	i=schema_repeat { l.Add(i); } ( PLUS i=schema_repeat { l.Add(i); } )*
		{ result = (l.Count == 1) ? (Schema.Base)l[0] : new Schema.Choice((Schema.Base[])l.ToArray(typeof(Schema.Base))); }
	;

schema_repeat returns [Schema.Base result = null]
	// TODO: we are ignoring the STAR component
	:	result=schema_ordered ( STAR )?
	;

schema_ordered returns [Schema.Base result = null]
	{ ArrayList l = new ArrayList(); Schema.Base i; }
	:	i=schema_simple { l.Add(i); } ( COMMA i=schema_simple { l.Add(i); } )*
		{ result = (l.Count == 1) ? (Schema.Base)l[0] : new Schema.Ordered((Schema.Base[])l.ToArray(typeof(Schema.Base))); }
	;

schema_simple returns [Schema.Base result = null]
	:	( tag LSQUARE ) => result=schema_element
	|	result=schema_name
	|	LPAREN result=schema RPAREN
	;
	
schema_name returns [Schema.Base result = null]
	:	KW_BOOL { result = Schema.Boolean.Instance; }
	|	KW_INT { result = Schema.Integer.Instance; }
	|	KW_FLOAT { result = Schema.FloatingPoint.Instance; }
	|	KW_CHAR { result = Schema.Character.Instance; }
	|	KW_STRING { result = Schema.String.Instance; }
	|	result=schema_ref
	;

schema_element returns [Schema.Base result = null]
	{ string t; Schema.Base s; }
	:	t=tag LSQUARE s=schema RSQUARE { result = new Schema.Element(t, s); }
	;

schema_ref returns [Schema.Base result = null]
	:	n:ID { result = new Schema.Reference(n.getText()); }
	;


// -----------------
// --- Processes ---
// -----------------
statement_list returns [ArrayList result = new ArrayList()]
	{ Action.Base i; }
	:	( i=statement { result.Add(i); } )*
	;

process_statement returns [Process.Base result = null]
	{ ArrayList l; }
	:	LCURLY l=statement_list RCURLY
		{ result = new Process.Sequence((Action.Base[])l.ToArray(typeof(Action.Base))); }
	;

statement returns [Action.Base result = null]
	:	( ID LPAREN pattern RPAREN ) => result=receive_statement SEMI
	|	( fork name LPAREN pattern RPAREN ) => result=fork_receive_statement
	|	( ID LPAREN value RPAREN ) => result=send_or_call_statement SEMI
	|	( fork KW_SWITCH ) => result=switch_statement
	|	( fork LCURLY ) => result=fork_statement
	|	result=fork_send_or_call_statement SEMI
	|	result=select_statement
	|	result=if_statement
	|	result=let_statement SEMI
	;

receive_statement returns [Action.Base result = null]
	{ string n; Pattern.Base p; }
	:	n=name LPAREN p=pattern RPAREN { result = new Action.Receive(n, p); }
	;

fork_receive_statement returns [Action.Base result = null]
	{ string n; Pattern.Base p; ArrayList l; }
	:	fork n=name LPAREN p=pattern RPAREN LCURLY l=statement_list RCURLY
		{ l.Insert(0, new Action.Receive(n, p)); result = new Action.Fork(new Process.Sequence((Action.Base[])l.ToArray(typeof(Action.Base)))); }
	;

send_or_call_statement returns [Action.Base result = null]
	// TODO
	:	name LPAREN value RPAREN
	;

fork_send_or_call_statement returns [Action.Base result = null]
	{ string n; Value.Base v; }
	:	fork n=name LPAREN v=value RPAREN { result = new Action.Fork(new Process.Send(n, v)); }
	;

select_statement returns [Action.Base result = null]
	// TODO
	:	KW_SELECT LCURLY ( fork_receive_statement )* RCURLY
	;

let_statement returns [Action.Base result = null]
	{ Pattern.Base p; Value.Base v; }
	:	p=pattern ASSIGN v=value { result = new Action.Let(p, v); }
	;

if_statement returns [Action.Base result = null]
	// TODO
	:	KW_IF LPAREN value RPAREN fork process_statement KW_ELSE fork process_statement
	;

switch_statement returns [Action.Base result = null]
	// TODO
	:	fork KW_SWITCH LPAREN value RPAREN LCURLY ( switch_case )* RCURLY
	;

switch_case returns [Action.Switch.Case result = null]
	// TODO
	:	KW_CASE pattern COLON ( statement )*
	;

fork_statement returns [Action.Base result = null]
	{ Process.Base p; }
	:	fork p=process_statement { result = new Action.Fork(p); }
	;

fork
	:	KW_FORK
	|	DOT
	;
